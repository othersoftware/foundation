"use strict";
const vite = require("vite");
const fs = require("node:fs");
const path = require("node:path");
function _interopNamespaceDefault(e) {
  const n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
  if (e) {
    for (const k in e) {
      if (k !== "default") {
        const d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: () => e[k]
        });
      }
    }
  }
  n.default = e;
  return Object.freeze(n);
}
const path__namespace = /* @__PURE__ */ _interopNamespaceDefault(path);
function scan(dir, extensions = [".vue"], list = []) {
  if (!fs.existsSync(dir)) {
    return list;
  }
  const files = fs.readdirSync(dir);
  files.forEach((file) => {
    const resolved = path.join(dir, file);
    const stats = fs.statSync(resolved);
    if (stats.isDirectory()) {
      list = scan(resolved, extensions, list);
    } else {
      extensions.forEach((extension) => {
        if (resolved.endsWith(extension)) {
          list.push(resolved);
        }
      });
    }
  });
  return list;
}
function toPascalCase(value) {
  return value.charAt(0).toUpperCase() + value.slice(1);
}
function asLaravel(path2, absolute, namespace = void 0) {
  absolute = vite.normalizePath(absolute);
  path2 = vite.normalizePath(path2);
  let compiled = absolute.replace(path2, "").replace(/^\//, "").replace(".vue", "").split("/").join(".");
  if (namespace) {
    return namespace + "::" + compiled;
  }
  return compiled;
}
function asComponent(path2, absolute, namespace = void 0) {
  absolute = vite.normalizePath(absolute);
  path2 = vite.normalizePath(path2);
  let segments = absolute.replace(path2, "").replace(/^\//, "").replace(".vue", "").split("/");
  if (namespace) {
    segments.unshift(namespace);
  }
  return segments.map(toPascalCase).join("");
}
function asGlobalComponent(absolute, namespace = void 0) {
  absolute = vite.normalizePath(absolute);
  let base = path.basename(absolute);
  let parsed = path.parse(base);
  let name = toPascalCase(parsed.name);
  if (namespace) {
    return toPascalCase(namespace) + name;
  }
  return name;
}
function collect(config, sources, namespace = void 0) {
  const vendors = /* @__PURE__ */ new Map();
  const components = /* @__PURE__ */ new Map();
  if (Array.isArray(sources)) {
    sources = Object.fromEntries(sources.map((s) => [s, void 0]));
  }
  if (typeof sources === "string") {
    sources = { [sources]: void 0 };
  }
  Object.entries(sources).forEach(([local, vendor]) => {
    if (vendor) {
      scanComponents(path.resolve(config.root, vendor), components, vendors, namespace);
    }
    scanComponents(path.resolve(config.root, local), components, void 0, namespace);
  });
  return { components, vendors };
}
function scanComponents(source, components, vendors = void 0, namespace = void 0) {
  scan(source).forEach((path2) => {
    let global = asGlobalComponent(path2, namespace);
    let laravel = asLaravel(source, path2, namespace);
    let name = asComponent(source, path2, namespace);
    path2 = vite.normalizePath(path2);
    if (vendors) {
      vendors.set(name, { global, name, laravel, path: path2 });
    }
    components.set(name, { global, name, laravel, path: path2 });
  });
}
function compileComponentsModule(components) {
  let lines = [];
  components.forEach((resolved) => lines.push(`import ${resolved.global} from '${resolved.path}';`));
  lines.push(`export {`);
  components.forEach((resolved) => lines.push(`  ${resolved.global},`));
  lines.push(`};`);
  lines.push(``);
  lines.push(`export function createOtherSoftwareAutoloader() {`);
  lines.push(`  return {`);
  lines.push(`    install(app) {`);
  components.forEach((resolved) => lines.push(`      app.component('${resolved.global}', ${resolved.global});`));
  lines.push(`    },`);
  lines.push(`  };`);
  lines.push(`};`);
  lines.push(``);
  return lines.join("\n");
}
function writeComponentsDeclarations$1(config, options, target, components) {
  let directory = path.resolve(config.root, target);
  let declarations = path.resolve(directory, "components.d.ts");
  let lines = [];
  lines.push(`// THIS FILE IS AUTOGENERATED!`);
  lines.push(`// DO NOT EDIT!`);
  lines.push(``);
  lines.push(`declare module '@${options.namespace}/components' {`);
  lines.push(`  import { Plugin } from 'vue';`);
  lines.push(`  export function createOtherSoftwareAutoloader(): Plugin;`);
  lines.push(``);
  components.forEach((resolved) => lines.push(`  export { default as ${resolved.global} } from '${vite.normalizePath(path.relative(directory, resolved.path))}';`));
  lines.push(`}`);
  lines.push(``);
  fs.writeFileSync(declarations, lines.join("\n"));
}
function writeVueDeclarations(config, target, components) {
  let directory = path.resolve(config.root, target);
  let declarations = path.resolve(directory, "vue.d.ts");
  let lines = [];
  lines.push(`// THIS FILE IS AUTOGENERATED!`);
  lines.push(`// DO NOT EDIT!`);
  lines.push(``);
  lines.push(`declare module '@vue/runtime-core' {`);
  lines.push(`  export interface GlobalComponents {`);
  components.forEach((resolved) => lines.push(`    ${resolved.global}: typeof import('${vite.normalizePath(path.relative(directory, resolved.path))}')['default'],`));
  lines.push(`  }`);
  lines.push(`}`);
  lines.push(``);
  lines.push(`export {}`);
  lines.push(``);
  fs.writeFileSync(declarations, lines.join("\n"));
}
function resolveTargetDirectory(target) {
  if (Array.isArray(target)) {
    return [target.at(0), void 0];
  }
  if (typeof target === "string") {
    return [target, void 0];
  }
  return Object.entries(target).at(0);
}
function provideVirtualComponentsModule(config, options, compile = true) {
  const target = resolveTargetDirectory(options.target);
  if (!target) {
    throw new Error("Unknown target for output files!");
  }
  let [local, vendor] = target;
  let views = collect(config, options.components);
  if (vendor) {
    writeComponentsDeclarations$1(config, options, vendor, views.vendors);
    writeVueDeclarations(config, vendor, views.vendors);
  }
  writeComponentsDeclarations$1(config, options, local, views.components);
  writeVueDeclarations(config, local, views.components);
  if (compile) {
    return compileComponentsModule(views.components);
  }
  return null;
}
function compileViewsModule(views) {
  let lines = [];
  views.forEach((resolved) => lines.push(`import ${resolved.name} from '${resolved.path}';`));
  lines.push(``);
  lines.push(`const ViewsRepository = {`);
  views.forEach((resolved) => lines.push(`  '${resolved.laravel}': ${resolved.name},`));
  lines.push(`};`);
  lines.push(``);
  lines.push(`export function createViewResolver(name) {`);
  lines.push(`  const view = ViewsRepository[name];`);
  lines.push(``);
  lines.push(`  if (!view) {`);
  lines.push(`    throw new Error('View "' + name + '" not found!');`);
  lines.push(`  }`);
  lines.push(``);
  lines.push(`  return view;`);
  lines.push(`}`);
  lines.push(``);
  return lines.join("\n");
}
function writeComponentsDeclarations(config, options, target) {
  let directory = path.resolve(config.root, target);
  let declarations = path.resolve(directory, "views.d.ts");
  let lines = [];
  lines.push(`// THIS FILE IS AUTOGENERATED!`);
  lines.push(`// DO NOT EDIT!`);
  lines.push(``);
  lines.push(`declare module '@${options.namespace}/views' {`);
  lines.push(`  export function createViewResolver(name: string): any;`);
  lines.push(`}`);
  lines.push(``);
  fs.writeFileSync(declarations, lines.join("\n"));
}
function writePhpstormMeta(config, target, views) {
  let directory = path.resolve(config.root, target);
  let meta = path.resolve(directory, ".phpstorm.meta.php");
  let lines = [];
  let compiled = [];
  views.forEach((view) => compiled.push(`'${view.laravel}'`));
  lines.push(`<?php`);
  lines.push(``);
  lines.push(`namespace PHPSTORM_META {`);
  lines.push(`  registerArgumentsSet('vueApplicationViews', ${compiled.join(", ")});`);
  lines.push(``);
  lines.push(`  expectedArguments(\\OtherSoftware\\Bridge\\ResponseFactory::view(), 0, argumentsSet('vueApplicationViews'));`);
  lines.push(`  expectedArguments(\\OtherSoftware\\Support\\Facades\\Vue::view(), 0, argumentsSet('vueApplicationViews'));`);
  lines.push(`}`);
  lines.push(``);
  fs.writeFileSync(meta, lines.join("\n"));
}
function provideVirtualViewsModule(config, options, compile = true) {
  const target = resolveTargetDirectory(options.target);
  if (!target) {
    throw new Error("Unknown target for output files!");
  }
  let [local, vendor] = target;
  const views = collect(config, options.views, options.namespace);
  if (vendor) {
    writeComponentsDeclarations(config, options, vendor);
    writePhpstormMeta(config, vendor, views.vendors);
  }
  writeComponentsDeclarations(config, options, local);
  writePhpstormMeta(config, local, views.components);
  if (compile) {
    return compileViewsModule(views.components);
  }
  return null;
}
let viewsMap = /* @__PURE__ */ new Map();
function collectViewsSet(config, options) {
  let collection = collect(config, options.views, options.namespace);
  let namespace = options.namespace || "default";
  let views = /* @__PURE__ */ new Set();
  viewsMap.set(namespace, views);
  collection.components.forEach((component) => {
    views.add(path__namespace.normalize(component.path));
  });
  collection.vendors.forEach((component) => {
    views.add(path__namespace.normalize(component.path));
  });
}
function resetViewsSet(config, options) {
  collectViewsSet(config, options);
}
function transformViewComponent(config, options, code, id) {
  if (!viewsMap.has(options.namespace || "default")) {
    collectViewsSet(config, options);
  }
  const resolvedId = path__namespace.normalize(id);
  if (!id.endsWith(".vue") || !viewsMap.get(options.namespace || "default").has(resolvedId)) {
    return { code, map: null };
  }
  if (code.includes("<template>") && !code.includes("<RouterView") && !code.includes("<router-view")) {
    const templateEnd = code.lastIndexOf("</template>");
    const beforeTemplate = code.slice(0, templateEnd);
    const afterTemplate = code.slice(templateEnd);
    return { code: `${beforeTemplate}
  <RouterView />
${afterTemplate}`, map: null };
  }
  return { code, map: null };
}
function autoloader(options) {
  let config;
  function refreshDeclarations(server) {
    provideVirtualComponentsModule(config, options, false);
    provideVirtualViewsModule(config, options, false);
    resetViewsSet(config, options);
    const components = server.moduleGraph.getModuleById("\0@" + options.namespace + "/components");
    const views = server.moduleGraph.getModuleById("\0@" + options.namespace + "/views");
    if (components) {
      server.reloadModule(components);
    }
    if (views) {
      server.reloadModule(views);
    }
  }
  return {
    name: "vue-autoloader",
    enforce: "pre",
    configResolved(resolvedConfig) {
      config = resolvedConfig;
    },
    resolveId(id) {
      if (id === "@" + options.namespace + "/components") return "\0@" + options.namespace + "/components";
      if (id === "@" + options.namespace + "/views") return "\0@" + options.namespace + "/views";
    },
    load(id) {
      if (id === "\0@" + options.namespace + "/components") return provideVirtualComponentsModule(config, options);
      if (id === "\0@" + options.namespace + "/views") return provideVirtualViewsModule(config, options);
    },
    async transform(code, id) {
      return transformViewComponent(config, options, code, id);
    },
    configureServer(server) {
      const handler = (path2) => {
        if (path2.endsWith(".vue")) {
          refreshDeclarations(server);
        }
      };
      server.watcher.on("add", handler);
      server.watcher.on("unlink", handler);
      server.watcher.on("addDir", handler);
      server.watcher.on("unlinkDir", handler);
    }
  };
}
module.exports = autoloader;
//# sourceMappingURL=other-software-autoloader.cjs.map
